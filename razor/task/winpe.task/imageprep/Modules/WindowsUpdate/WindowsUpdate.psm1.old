# WindowsUpdate.psm1
#

# Search-WindowsUpdates | ?{ $_.Title -match "foo" } | Install-WindowsUpdates

$updateSession = $Null

function Get-WindowsUpdateHistory {
  Search-WindowsUpdates -History
}

function Search-WindowsUpdates {
  [CmdletBinding()]   
  Param(
    [switch]$ImportantOnly,
    [switch]$All,
    [switch]$History,
    [switch]$DownloadOnly
  )

  Write-Verbose $MyInvocation.MyCommand
  Write-Verbose "  -ImportantOnly : $ImportantOnly"
  Write-Verbose "  -All           : $All"

  if ($ImportantOnly -and $All) { 
    Throw "ERROR: The switches -ImportantOnly and -All are mutually exclusive."
  }

  $Global:updateSession = New-Object -ComObject Microsoft.Update.Session
  $updateSearcher = $Global:updateSession.CreateupdateSearcher()

  if ($History) {
    Write-Verbose "Listing History ..."
    $updateSearcher.QueryHistory(1, $updateSearcher.GetTotalHistoryCount())
    return
  }

  Write-Verbose "Searching for updates ..."
  $searchString = "IsInstalled=0 and IsAssigned=1"
  if (-not($All)) { $searchString += " and AutoSelectOnWebSites=1" } # Install ImportantOnly by default
  Write-Verbose "searchString : $searchString"
  $searchResult = $updateSearcher.Search($searchString)

  if ($VerbosePreference -imatch "Continue") { # optimization
    Write-Verbose "Number of updates found: $($searchResult.Updates.Count)"
    $searchResult.Updates | %{ Write-Verbose "  * $($_.Title)" }
  }

  return $searchResult

}

function Install-WindowsUpdates {
  [CmdletBinding()]   
  Param(
    [switch]$ImportantOnly,
    [switch]$All,
    [switch]$DownloadOnly,
    [parameter(Position = 0, Mandatory=$False,ValueFromPipeline=$True)]$searchResult
  )

  begin {
    Write-Verbose $MyInvocation.MyCommand

    if ( -not($All) -and -not($ImportantOnly) ) { $ImportantOnly = $True }
    Write-Verbose "  -ImportantOnly : $ImportantOnly"
    Write-Verbose "  -All           : $All"
    Write-Verbose "  -DownloadOnly  : $DownloadOnly"

  }

  process {
    if ( -not($searchResult) ) {
      Write-Verbose " Empty pipeline, performing a new WU Search"
      $searchResult = Search-WindowsUpdates @PSBoundParameters
    }

    Write-Verbose "Number of updates found: $($searchResult.Updates.Count)"
    if ( $searchResult.Updates.Count -eq 0 ) { return }

    #if ( -not($searchResult.Updates.Count) ) { return $True }
    #return

    $updatesTodownload = New-Object -ComObject Microsoft.Update.UpdateColl
    $searchResult.Updates | %{
      if ($_.InstallationBehavior.CanRequestUserInput) {
        Write-Host -ForegroundColor Magenta "Update requires user input: " $_.Title 
        $_ | fl *
      }
      else {
        if (-not($_.IsDownloaded)) { $updatesTodownload.Add( $_ ) > $Null }
      }
    }

    Write-Verbose "Update candidates to download: $($updatesToDownload.Count)"
    $i=0; $updatesToDownload | %{ Write-Verbose "  * $($i++) $($_.Title)" }

    if ($updatesToDownload.Count) {
      Write-Verbose "Downloading updates ..."
      $downloader         = $Global:updateSession.CreateUpdateDownloader()
      $downloader.Updates = $updatesToDownload
      try {
        $downloader.Download() > $Null
      }
      catch {
        Write-Verbose "Problem downloading updates." $_
        Write-Verbose " " $error[0]
      }
    }
    if ($DownloadOnly) { return $updatesToDownload }

    Write-Verbose "Accepting EULAs ..."
    $updatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
    $searchResult.Updates | ?{ $_.IsDownloaded } | %{ $_.AcceptEULA(); $updatesToInstall.Add( $_ ) > $Null }

    Write-Verbose "Updates to install: $($updatesToInstall.Count)"
    $i=0; $updatesToInstall | %{ Write-Verbose "  * $($i++) $($_.Title)" }

    Write-Verbose "Setting Update Installer preferences for automation ..."
    $installer                    = $Global:updateSession.CreateUpdateInstaller()
    $installer.Updates            = $updatesToInstall
    $installer.AllowSourcePrompts = $false
    $installer.ForceQuiet         = $true

    Write-Verbose "Installing updates..."
    $installationResult = $installer.Install()

    Write-Verbose "Installation Result: $($installationResult.Resultcode)"
    Write-Verbose "Reboot Required: $($installationResult.RebootRequired)"

    return $installationResult
  }

}


# ---- Customs ----
Export-ModuleMember Install-WindowsUpdates, Search-WindowsUpdates, Get-*

# function Resolve-KBByID {
#   Param(
#     [Parameter(Mandatory=$True)] $ID    
#   )
# 
#   if ($ID -imatch "^kb") {
#     $ID = $ID -replace "^[Kk][Bb]", ""
#   } 
# 
#   $targetFile = Join-Path $Env:TEMP "kb${ID}.html"
# 
#   if (-Not (Test-Path $targetFile)) {
#     $webClient = New-Object System.Net.WebClient
#     $url = "http://support.microsoft.com/?kbid=$ID"
#     try {
#       $webClient.DownloadFile($url, $targetFile)
#     }
#     catch {
#       Write-Error "Error downloading '$url' to '$targetfile'"
#       Write-Error $error
#       return $False
#     }
#   }
# 
# }
# 
# function List-InstalledHotFixes() {
#   Get-HoxFix
#   # Get-WMIObject -Class Win32_QuickFixEngineering
# }





### Old Main
#
# $installationResult = installUpdates($updateSession)
# 
# 
# if( ($installationResult.Resultcode -eq 2) -or ($installationResult.ResultCode -eq 3))
# {
#     if($installationResult.RebootRequired)
#     {
#         exit 10
#     }
#     else
#     {
#         exit 0
#     }
# }
# else
# {
#     exit $installationResult.ResultCode
# }
#
### 
#  for ($i = 0; $i -lt $updatesToDownload.Count; $i++) {
#    $update = $updatesToDownload.Item($i)
#    if($update.IsDownloaded) {
#      Write-Host "$($i+1) > $($update.Title)"
#    } else {
#      Write-Host -ForegroundColor magenta "Warning: $($update.Title) failed to download."
#    }
#  }
  #  for($i = 0; $i -lt $updatesToDownload.count; $i++) {
  #    $update = $updatesToDownload.Item($i)
  #    if($update.IsDownloaded) {
  #      $update.AcceptEula() # Is this acceptable?
  #      $updatesToInstall.Add($update)
  #    }
  #  }

  #  for ($i = 0; $i -lt $searchResult.Updates.Count; ++$i) {
  #    $update = $searchResult.Updates.Item($i)
  #    if ($update.InstallationBehavior.CanRequestUserInput -eq $false) {
  #      $updatesTodownload.Add($update) | Out-Null
  #    } else {
  #      Write-Host -ForegroundColor cyan "$update requires User Input"
  #    }
  #  }
  # Write-Host "List of downloaded updates:"
  # $i=0; $updatesToDownload | ?{ $_.IsDownloaded } | %{ Write-Host ($i++)" "$_.Title }

